\section{Versionskontrolle}
\subsection{Versionskontrollsysteme (VCS)}

\begin{multicols}{2}
	\subsubsection{Zweck}
	\begin{itemize}
		\item Aufbewahrung, Verwaltung, Wiederherstellen von früheren Versionen in einem Archiv
		\item Koordination des Zugriffs, bekannt als File-Sharing
		\item erlaubt hervorholen von alten Versionen
	\end{itemize}
	
	\subsubsection{Haupteinsatz}
	\begin{itemize}
		\item Softwareentwicklung: zur Verwaltung des Source-Codes
		\item Dokument-Management-Systeme (DMS)
		\item Archiv $=$ Repository $=$ Lager
	\end{itemize}
\end{multicols}

\subsubsection{Hauptaufgaben von VCS}
\begin{minipage}{\linewidth}
	\begin{itemize}
		\item \textcolor{blue}{Protokollierungen} der Änderungen: \newline $\rightarrow$ Es kann jederzeit nachvollzogen werden, wer wann was geändert hat.
		\item \textcolor{blue}{Wiederherstellung} von alten Ständen (Milestones) einzelner Dateien: \newline $\rightarrow$ Versehentliche Änderungen können jederzeit rückgängig gemacht werden.
		\item \textcolor{blue}{Koordinierung} des gemeinsamen Zugriffs auf die Dateien eines Projektes. \newline $\rightarrow$ Mehrere Mitarbeiter können gefahrlos auf die Dateien eines Projektes zugreifen. 
		\item \textcolor{blue}{Mehrere Entwicklungszweige} (engl. \"{}Branches\"{})\newline $\rightarrow$ Es kann gleichzeitig an verschiedenen Entwicklungszweigen gearbeitet werden. \newline $\rightarrow$ Ein \"{}Branch\"{} ist eine Abspaltung von der normalen Entwicklungslinie, bei der z.B. eine alternative Lösung für ein Teilproblem untersucht wird.
	\end{itemize}
\end{minipage}
\subsubsection{Einteilung von VCS}
	\begin{itemize}
\item \textcolor{blue}{Lokale (dateibasierte) Versions-Kontrollsysteme}
\begin{itemize}
\item \"{}Local Version Contol System\"{} (LVCS)
 \item Dateibasiert = \textbf{ein} Archiv für \textbf{jede} zu archivierende Datei
 \item Der Name der Archiv-Datei wird dabei vom Namen des Source-Files abgeleitet. \newline $\rightarrow$ \texttt{hallo.cpp} $\rightarrow$ \texttt{hallo.cpp\textbf{,v}} (Suffix '\textbf{,v}') 
 \item Die im Archiv \"{}abc.xyz,v\"{} abgespeicherte Versionen der Datei \"{}abc.xyz\"{} werden \"{}Revisionen\"{} genannt.
 \item Wichtige Operationen:
 \begin{itemize}
 	\item \textbf{\"{}check-in\"{}:} Datei zu Archiv hinzufügen (neue Revision) \newline $\rightarrow$ \texttt{\$ ci -m \"{}first check-in\"{} hallo.cpp \qquad \# \"{}einchecken\"{}}
 	\item \textbf{\"{}checkout\"{}:} eine bestimmte Revision aus dem Archiv holen \newline $\rightarrow$ \texttt{\$ co -l hallo.cpp\qquad \# \"{}auschecken\"{} und \"{}locken\"{}}
 \end{itemize}
\end{itemize}
\item \textcolor{blue}{Zentralisierte Versions-Kontrollsysteme}
\begin{itemize}
	\item \"{}Centralized Version Control Systems\"{} (CVCS)
	\item \textbf{\textit{Ein}} zentrales Archiv für alle zu archivierende Dateien. 
\end{itemize}
\item \textcolor{blue}{Verteilte Versions-Kontrollsysteme}
\begin{itemize}
	\item \"{}Distributed Version Control Systems\"{} (DVCS)
	\item \textbf{\textit{Mehrere, verteilte, gleichberechtigte}} Archive für die zu archivierenden Dateien
	\item \textbf{Git}, gehört in diese Sparte!
\end{itemize}
\end{itemize}
\clearpage
\subsection{Git}
\begin{itemize}
	\item Git $\rightarrow$ (engl. Blödmann)
	\item Entwickelt von Linus Torvalds, Linux-Erfinder
	\item Ziele waren Geschwindigkeit, Einfachheit, Unterstützung von nichtlinearer Entwicklung, \newline vollständig verteilt (distributed Repos), Verwaltung von grossen Projekten
	\item Ist ein spezielles Filesystem
	\item Git ist ein DVCS
\end{itemize}

\subsubsection{Allgemeines}
\begin{tabular}{|l|l|}
	\hline \textbf{Repository} &
    Ist ein Archiv für ein Projekt und enthält alle Änderungen und Versionen
    \\ 	\hline     
    \textbf{Branch} &
    Beschreibt zusammenhängende Änderungen in einem Projekt. Es gibt Minimum einen  bis beliebig viele.
    \\
    &
    Der Master-Branch ist der Produktivzweig
    \\ \hline
    \textbf{Commit} &
    Beschreibt eine Änderung in einem Branch an einer Datei mit Änderungsinformation
    \\ \hline
    \textbf{Snapshot} &
    Momentanes Zeitabbild des Projektes
    \\ \hline
    \textbf{Merge} &
    Zusammenführen von Änderungen aus zwei Branches
    \\	\hline
    \textbf{Stagen} &
    Datei zum Index hinzufügen
    \\\hline
\end{tabular}
\\
\\
\begin{tabular}{|c|c|}
	\hline \textbf{Lifecycle von Dateien} & \textbf{Branch}\\
	\hline \tabbild[width=9cm]{images/git_lifecycle.png} & \tabbild[width=9cm]{images/git_branch.png}\\
	\hline
\end{tabular}

\subsubsection{Git-Konzepte}
\begin{itemize}
	\item Git-Workspace ist ein Verzeichnis welches die zu bearbeitenden Dateien eines Projektes enthält
	\item In diesem Verzeichnis ist ein Unterverzeichnis \textit{".git"}
	\item Dieses Unterverzeichnis \textit{".git"} bildet das lokale Repository
	\item Im Branch zeigen die Pointer immer auf den vorhergehenden Commit
\end{itemize}

\subsubsection{Datenbereiche}
\begin{tabular}{|l|l|}
	\hline
	\begin{tabular}[c]{@{}l@{}}\textbf{Workspace}\\ -Projektverzeichniss\\ -enthält die Dateien mit denen man arbeitet\end{tabular}   & \begin{tabular}[c]{@{}l@{}}\textbf{Repository}\\ -enthält die Versionsgeschichte in Form von Commits (Revision)\\ -lokal/remote\end{tabular}   \\ \hline
	\begin{tabular}[c]{@{}l@{}}\textbf{Stash}\\ -Lager\\ -zum temporären Speichern der Workspace-Daten\end{tabular} & \begin{tabular}[c]{@{}l@{}}\textbf{Staging Area/Index/Cache}\\ -sammelt Änderungen für Commits\\ -Bereitstellungsraum\end{tabular} \\ \hline
\end{tabular}
\\
	\includegraphics[width=12cm]{images/git.png}

\subsubsection{Git-Repository}
\begin{itemize}
	\item \textbf{lokales Repository} $\rightarrow$ \textit{".git"}-Verzeichniss im Workspace
	\item \textbf{remote Repository} $\rightarrow$ Ein normales Git-Repository ohne Projektverzeichnis an externem Ort
	\item \textbf{\"{}bare\"{} Repository} $\rightarrow$ Git-Repository ohne Projektverzeichnis zum teilen, Klon von lokalen Repositories
\end{itemize}
\subsubsection{Git-Hashwerte}
\begin{itemize}
	\item Zur Identifizierung von Commits (und anderen Git-Objekten) werden sogenannte Hash-Werte verwendet
	\item Diese werden mittels SHA1-Algorithmus berechnet.\newline $\rightarrow$ SHA-1 = \"{}Secure Hash Algorithmus Version 1\"{}\newline
	$\rightarrow$ Dieser liefert 160 Bits (40 Hex Ziffern), \textbf{eindeutiger Prüfwert} für beliebige Daten
	\item die Hash-Werte werden als Zweigerwerte (Adressen) verwendet um die Repository-Datenstruktur aufzubauen
	\item Der Hashwert wird aus dem Dateiinhalt berechnet und für den Dateinamen verwendet
\end{itemize}
\subsubsection{Ein existierendes Verzeichnis als Repository initialisieren}
\includegraphics[width = 13cm]{images/bsprepo}
\subsubsection{Git-Objekte}
- Git-Objekte sind einfache Dateien im Verzeichnis \"{}.git/objects/\"{}\\
- Dabei werden \textbf{die ersten zwei Hex-Ziffern als Namen für ein Unterverzeichnis} verwendet, die restlichen 38 für den Namen der Datei in diesem Unterverzeichnis.\\\\
\includegraphics[width = 12cm]{images/gitobjekte}\\
	\begin{tabular}{|p{0.5\linewidth}|p{0.51\linewidth}|}
		\hline
		\begin{tabular}[c]{@{}l@{}}\textbf{blob} (\"{}binary large Object\"{})\\ -Inhalt einer Datei\\ -enthält \textit{keine} Zeiger auf andere Git-Objekte\end{tabular}   \newline  \includegraphics[width = 4cm]{images/blob}                             & \begin{tabular}[c]{@{}l@{}}\textbf{tree}\\ -enthält Zeiger auf blob-, oder tree-objekte\\ -enthält Referenzen über Git-Objekte, Ordner- \& Dateinamen\end{tabular} \newline \includegraphics[width = 4cm]{images/tree} \\ \hline
		\begin{tabular}[c]{@{}l@{}}\textbf{commit}\\ -Startobjekt für einen Commit\\ -enthält Zeiger auf tree und vorgängiges Commit-Objekt\end{tabular} \newline \includegraphics[width = 4cm]{images/commit}& \begin{tabular}[c]{@{}l@{}}\textbf{tag}\\ -Etikette mit Kommentar\\ -enthält Zeiger auf ein Commit-Objekt\end{tabular} \newline \includegraphics[width = 4cm]{images/tag}                                             \\ \hline
	\end{tabular}

\subsubsection{Git-Referenzen}
\begin{minipage}{10cm}
	\begin{itemize}
		\item Referenzen $=$ Zeiger (nur Zeigerwerte)
		\item Zeigen nur auf Git-Objekte
		\item Hashwert-Zeiger $\rightarrow$ zeigt auf Branches/Tags
		\item Symbolischer-Zeiger $\rightarrow$ zeigt auf Datei mit Namen eines anderen Zeigers
	\end{itemize}
\end{minipage}
\begin{minipage}{8cm}
	\includegraphics[width=8cm]{images/git-referenz.png}
\end{minipage}
\subsubsection{Bashprints}
\begin{multicols}{2}
	\begin{minipage}[l]{.40\textwidth}
		Files changed but not staged.\\    
		\textbf{\$ git status}\\
		On branch master\\
		Your branch is up-to-date with 'origin/master'.\\
		Changes not staged for commit:\\
		\quad (use "git add <file>..." to update what will be committed)\\
		\quad (use "git checkout -- <file>..." to discard changes in working directory)\\
		\\
		\qquad modified:\quad idiotenseite/IdiotenseiteInclude.tex\\
		\\
		no changes added to commit \newline (use \"{}git add\"{} and/or \"{}git commit -a\"{})\\
	\end{minipage}
	
	\begin{minipage}[r]{.40\textwidth}
		\textbf{\$ git log}\\
		commit 1b7ff854a491397087ff89689a535c275549e6ee\\
		Author: \quad Michel Gisler <Michel Gisler>\\
		Date:  \quad  Tue May 31 15:08:58 2016 +0200\\
		\\  
		\qquad Kleiner Ergänzungen und Anpassungen\\
	\end{minipage}
\end{multicols}
\clearpage
\pagebreak
\subsubsection{Git Commands}
\begin{longtable}{| p{.30\textwidth} | p{.70\textwidth} |}
	\hline 
	\textbf{Create}&
	\\ \hline
	
	git init <directory>&
	Create empty Git repo in specified directory.\newline
	Run with no arguments to initialize the current directory as a git repository.
	\\ \hline 
	
	git clone <repo>& 
	Clone repo located at <repo> onto local machine.\newline
	Original repo can be located on the local filesystem or on a remote machine
	\\ \hline  \hline
	
	\textbf{Local Changes}&
	\\ \hline 
	
	\hline 
	git status&
	List which files are staged, unstaged, and untracked  
	\\ \hline
	
	git diff& 
	Show unstaged changes between your index and working
	directory 
	\\ \hline 
	
	git diff HEAD&
	Show difference between working directory and last commit.
	\\ \hline
	
	git add <directory>&
	Stage all changes in <directory> for the next commit. Replace <directory>
	with a <file> to change a specific file or witch <.> to Stage all.
	\\ \hline 
	
	git commit -m " \" <message>"&
	Commit the staged snapshot, but instead of launching a text editor, use
	<message> as the commit message.
	\\ \hline
	
	git commit -a&
	Commit all local changes in tracked files.  
	\\ \hline 
	
	gitt commit --amend&
	Change the last commit. \textbf{Don‘t amend published commits!}
	\\ \hline \hline
	
	\textbf{Commit History}&  
	\\ \hline 
	
	\hline
	git log&
	Display the entire commit history using the default format.
	\\ \hline 
	
	git log -p <file>&
	Show changes over time for a specific file 
	\\ \hline
	
	git log --author="\"<pattern>"&
	Search for commits by a particular author. 
	\\ \hline
	
	git blame <file>& 
	Who changed what and when in <file>
	\\ \hline \hline
	
	\textbf{Branches and Tags}&  
	\\ \hline
	
	\hline
	git branch&
	List all of the branches in your repo. Add a <branch> argument to
	create a new branch with the name <branch>.
	\\ \hline 
	
	git branch <new-branch>&
	Create a new branch based
	on your current HEAD
	\\ \hline
	
	git branch -d <branch>&
	Delete a local branch
	\\ \hline   
	
	git branch -dr <remote/branch>&
	Delete a branch on the remote
	\\ \hline
	
	git checkout -b <branch>&
	Create and check out a new branch named <branch>. Drop the -b
	flag to checkout an existing branch.
	\\ \hline 
	
	git merge <branch>&
	Merge <branch> into the current branch.
	\\ \hline
	
	git tag <tag-name>&
	Mark the current commit with a tag (v1.0.1)
	\\ \hline  \hline
	
	\textbf{Update and Publish}&
	\\\hline 
	
	\hline
	git remote -v&
	List all currently configured remotes.
	\\ \hline 
	
	git remote add <name> <url>& 
	Add new remote repository, named <remote>
	\\ \hline 
	
	git fetch <remote>&  
	Download all changes from <remote>,
	but don‘t integrate into HEAD
	\\ \hline
	
	git pull <remote> <branch>&
	Download changes and directly merge/integrate into HEAD  
	\\ \hline 
	
	git push <remote> <branch>&
	Publish local changes on a remote
	\\ \hline \hline
	
	\textbf{ Merge and Rebase}&
	\\\hline 
	
	\hline
	git merge <branch>&
	Merge <branch> into your current HEAD
	\\ \hline 
	
	git rebase <branch>& 
	Rebase your current HEAD onto <branch>!\textbf{Don‘t rebase published commits!}
	\\ \hline 
	
	git rebase --abort&
	Abort a rebase
	\\ \hline 
	
	git mergetool& 
	Use your configured merge tool to solve conflicts
	\\ \hline \hline
	
	\textbf{Undo}&
	\\\hline 
	
	\hline
	git reset --hard HEAD&
	Discard all local changes in your working directory.
	\\ \hline  
	
	git checkout HEAD <file>&
	Discard local changes in a specific file
	\\ \hline   
	
	git revert <commit>&
	Revert a commit (by producing a new commit with contrary changes)
	\\ \hline    
	
	git reset <commit>&
	Move the current branch tip backward to <commit>, reset the staging area to match, but leave the working directory alone. 
	\\ \hline
\end{longtable}
